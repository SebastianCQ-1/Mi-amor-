<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Te Amo ❤️</title>
  <style>
    html, body { height:100%; margin:0; overflow:hidden;
      background: radial-gradient(ellipse at center, #0c0c14 0%, #06060a 100%); }
    canvas{display:block}
    h1{
      position:fixed; top:15px; width:100%; text-align:center; z-index:10; pointer-events:none;
      color:#ff6b6b; font:700 2.2rem/1.1 system-ui,Segoe UI,Roboto,Inter,Arial;
      text-shadow:0 0 15px rgba(255,107,107,.7); letter-spacing:2px;
      transform-origin:center top;
    }
    .hint{position:fixed;left:12px;bottom:12px;color:#fff;font:12px/1.4 system-ui,Segoe UI,Roboto,Inter,Arial;
      opacity:.7;user-select:none;background:rgba(255,255,255,.06);padding:.5rem .6rem;border-radius:.6rem;backdrop-filter:blur(6px)}
  </style>
</head>
<body>
  <h1 id="title">Te Amo</h1>
  <div class="hint">Arrastra para orbitar • Rueda para zoom</div>

  <!-- LIBS sin módulos (compatibles con GitHub Pages) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

  <script>
    // ===== SETUP =====
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 1200, 2200);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 5000);
    camera.position.set(0,0,520);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 200;
    controls.maxDistance = 1400;

    scene.add(new THREE.AmbientLight(0xffffff, 0.45));

    const tl = gsap.timeline({ repeat:-1, yoyo:true });

    // ===== CORAZÓN PARAMÉTRICO (sin SVG) =====
    // Fórmula clásica:
    // x = 16 sin^3 t
    // y = 13 cos t - 5 cos2t - 2 cos3t - cos4t
    const verts = [];
    const N = 4200;                // puntos (sube/baja para más/menos partículas)
    const s = 18;                  // escala del corazón
    for (let i = 0; i < N; i++){
      const t = (i / N) * Math.PI * 2;
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);

      const v = new THREE.Vector3(x*s, -y*s, 0);

      // Volumen (jitter)
      v.x += (Math.random()-0.5) * 26;
      v.y += (Math.random()-0.5) * 26;
      v.z += (Math.random()-0.5) * 70;

      verts.push(v);

      // Animación desde el centro (0,0,0)
      tl.from(v, {
        x: 0, y: 0, z: 0,
        ease: "power2.inOut",
        duration: gsap.utils.random(2,5)
      }, i * 0.002);
    }

    // Geometría (una sola vez) + atributos
    const positions = new Float32Array(verts.length*3);
    const colors = new Float32Array(verts.length*3);
    const col = new THREE.Color();

    for (let i=0;i<verts.length;i++){
      positions[i*3+0] = verts[i].x;
      positions[i*3+1] = verts[i].y;
      positions[i*3+2] = verts[i].z;

      col.setHSL(0.96 + (Math.random()*0.02 - 0.01), 0.75, 0.60 + (Math.random()*0.08 - 0.04));
      colors[i*3+0] = col.r; colors[i*3+1] = col.g; colors[i*3+2] = col.b;
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 3,
      vertexColors: true,
      transparent: true,
      opacity: 0.95,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // Latido (partículas) + latido del título
    gsap.to(particles.scale, { x:1.04, y:1.04, z:1.04, duration:0.9, ease:"sine.inOut", yoyo:true, repeat:-1 });
    gsap.to("#title", { scale:1.04, duration:0.9, ease:"sine.inOut", yoyo:true, repeat:-1 });

    // Oscilación de la escena
    gsap.fromTo(scene.rotation, { y:-0.2 }, { y:0.2, duration:3, ease:"power2.inOut", yoyo:true, repeat:-1 });

    const posAttr = geometry.getAttribute("position");

    // ===== LOOP =====
    function render(){
      requestAnimationFrame(render);
      controls.update();

      // Actualiza posiciones según los Vector3 animados
      for (let i=0;i<verts.length;i++){
        posAttr.array[i*3+0] = verts[i].x;
        posAttr.array[i*3+1] = verts[i].y;
        posAttr.array[i*3+2] = verts[i].z;
      }
      posAttr.needsUpdate = true;

      renderer.render(scene, camera);
    }
    render();

    // ===== RESIZE =====
    addEventListener("resize", ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>


